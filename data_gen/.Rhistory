w_tmp_raw[!is.na(b_tmp_vec)] <-
pgdraw(b_tmp_vec[!is.na(b_tmp_vec)],
c_tmp_vec[!is.na(b_tmp_vec)])
w_tmp <- matrix(w_tmp_raw, nrow = N_tmp)
Omega_tmp <- array(0,dim = c(N_tmp, N_tmp, T_tmp))
Yhat_tmp <- matrix(0, nrow = N_tmp, ncol = T_tmp)
for(t in 1:T_tmp){
# (b) calculate \Omega_t
Omega_tmp[,,t] <- diag(w_tmp[,t])
# (c) calculate yhat_t
kt_tmp <- (Y_tmp[,t] - R_tmp[,t])/2 +
w_tmp[,t]*(log(R_tmp[,t]) - delta_tmp)
Yhat_tmp[,t] <- (1/w_tmp[,t])*kt_tmp
}
## (2) FF: forward filtering-- calculate m_t, V_t
m_tmp <- matrix(0, nrow = p_tmp, ncol = T_tmp)
V_tmp <- array(0, dim = c(p_tmp, p_tmp, T_tmp))
for(t in 1:T_tmp){
if(t == 1){
m_tt_1 <- A %*% m0 + b
V_tt_1 <- A %*% V0 %*% t(A) + Sig
}else{
m_tt_1 <-  A %*% m_tmp[,t-1] + b
V_tt_1 <- A %*% V_tmp[,,t-1]%*% t(A) + Sig
}
obsIdx <- !is.na(Yhat_tmp[,t])
X_tmp2 <- X_tmp[obsIdx,]
Omega_tmp2 <- Omega_tmp[obsIdx,obsIdx,t]
Yhat_tmp2 <- Yhat_tmp[obsIdx,t]
if(sum(obsIdx) > 0){
Kt <- V_tt_1 %*% t(X_tmp2) %*%
solve(X_tmp2 %*% V_tt_1 %*% t(X_tmp2) + solve(Omega_tmp2))
m_tmp[,t] <- m_tt_1 + Kt %*% (Yhat_tmp2 - X_tmp2 %*% m_tt_1)
V_tmp[,,t] <- (diag(p_tmp) - Kt %*% X_tmp2) %*% V_tt_1
V_tmp[,,t] <- (V_tmp[,,t] + t(V_tmp[,,t]))/2
}else{
m_tmp[,t] <- m_tt_1
V_tmp[,,t] <- V_tt_1
}
}
## (3) BS: backward sampling
BETA_b[,T_tmp] <- rmvnorm(1, mean = m_tmp[,T_tmp],
sigma = as.matrix(V_tmp[,,T_tmp]))
for(t in (T_tmp-1):1){
# print(t)
Jt <- V_tmp[,,t] %*% t(A) %*%
solve(t(A) %*% V_tmp[,,t] %*% t(A) + Sig)
mstar_tmp <- m_tmp[,t] + Jt %*%
(BETA_b[,t+1] - A %*% m_tmp[,t] - b)
Vstar_tmp <- (diag(p_tmp) - Jt %*% A) %*% V_tmp[,,t]
Vstar_tmp <- (Vstar_tmp + t(Vstar_tmp))/2
BETA_b[,t] <- rmvnorm(1, mean = mstar_tmp,
sigma = Vstar_tmp)
}
theta_a <- THETA[[g-1]][[j]]
delta_tmp <- delta_fit[idx_tmp,g-1]
C_tmp
Y_tmp <- Y[idx_tmp,]
R_tmp <- matrix(10, nrow = sum(idx_tmp), ncol = T_all)
theta_b <- theta_a
N_tmp <- dim(Y_tmp)[1]
T_all <- dim(Y_tmp)[2]
p_tmp <- dim(theta_a$X)[1]
# (1) sample proposal
muX_new <- PG_FFBS(rbind(theta_a$mu, theta_a$X),
Y_tmp,cbind(rep(1,N_tmp), C_tmp),
theta_a$A,theta_a$b,
theta_a$Q,c(prior$mu0, prior$x0),
diag(c(prior$Sigmu0, diag(prior$Q0))),
R_tmp,delta_tmp)
Y_tmp
cbind(1, C_tmp)
cbind(rep(1,N_tmp), C_tmp)
delta_tmp
PG_FFBS <- function(BETA_a,
Y_tmp,X_tmp,A,b,
Sig,m0,
V0,R_tmp,
delta_tmp){
# to debug
# BETA_a <- rbind(theta_a$mu, theta_a$X)
# X_tmp <- cbind(rep(1,N_tmp), C_tmp)
# A <- theta_a$A
# b <- theta_a$b
# Sig <- theta_a$Q
# m0 <- c(prior$mu0, prior$x0)
# V0 <- diag(c(prior$Sigmu0, diag(prior$Q0)))
p_tmp <- dim(BETA_a)[1]
T_tmp <- dim(BETA_a)[2]
N_tmp <- dim(Y_tmp)[1]
BETA_b <- BETA_a
## (1) calculate r_{nt}, \hat{w}_{nt}, \Omega_t, \hat{y}_t
ETA_tmp <- X_tmp %*% BETA_a + delta_tmp
b_tmp <- R_tmp + Y_tmp
c_tmp <- ETA_tmp - log(R_tmp)
# (a) draw PG sample
w_tmp_raw <- rep(NA, N_tmp*T_tmp)
b_tmp_vec <- c(b_tmp)
c_tmp_vec <- c(c_tmp)
w_tmp_raw[!is.na(b_tmp_vec)] <-
pgdraw(b_tmp_vec[!is.na(b_tmp_vec)],
c_tmp_vec[!is.na(b_tmp_vec)])
w_tmp <- matrix(w_tmp_raw, nrow = N_tmp)
Omega_tmp <- array(0,dim = c(N_tmp, N_tmp, T_tmp))
Yhat_tmp <- matrix(0, nrow = N_tmp, ncol = T_tmp)
for(t in 1:T_tmp){
# (b) calculate \Omega_t
Omega_tmp[,,t] <- diag(w_tmp[,t])
# (c) calculate yhat_t
kt_tmp <- (Y_tmp[,t] - R_tmp[,t])/2 +
w_tmp[,t]*(log(R_tmp[,t]) - delta_tmp)
Yhat_tmp[,t] <- (1/w_tmp[,t])*kt_tmp
}
## (2) FF: forward filtering-- calculate m_t, V_t
m_tmp <- matrix(0, nrow = p_tmp, ncol = T_tmp)
V_tmp <- array(0, dim = c(p_tmp, p_tmp, T_tmp))
for(t in 1:T_tmp){
if(t == 1){
m_tt_1 <- A %*% m0 + b
V_tt_1 <- A %*% V0 %*% t(A) + Sig
}else{
m_tt_1 <-  A %*% m_tmp[,t-1] + b
V_tt_1 <- A %*% V_tmp[,,t-1]%*% t(A) + Sig
}
obsIdx <- !is.na(Yhat_tmp[,t])
X_tmp2 <- X_tmp[obsIdx,]
Omega_tmp2 <- Omega_tmp[obsIdx,obsIdx,t]
Yhat_tmp2 <- Yhat_tmp[obsIdx,t]
if(sum(obsIdx) > 0){
Kt <- V_tt_1 %*% t(X_tmp2) %*%
solve(X_tmp2 %*% V_tt_1 %*% t(X_tmp2) + solve(Omega_tmp2))
m_tmp[,t] <- m_tt_1 + Kt %*% (Yhat_tmp2 - X_tmp2 %*% m_tt_1)
V_tmp[,,t] <- (diag(p_tmp) - Kt %*% X_tmp2) %*% V_tt_1
V_tmp[,,t] <- (V_tmp[,,t] + t(V_tmp[,,t]))/2
}else{
m_tmp[,t] <- m_tt_1
V_tmp[,,t] <- V_tt_1
}
}
## (3) BS: backward sampling
BETA_b[,T_tmp] <- rmvnorm(1, mean = m_tmp[,T_tmp],
sigma = as.matrix(V_tmp[,,T_tmp]))
for(t in (T_tmp-1):1){
# print(t)
Jt <- V_tmp[,,t] %*% t(A) %*%
solve(t(A) %*% V_tmp[,,t] %*% t(A) + Sig)
mstar_tmp <- m_tmp[,t] + Jt %*%
(BETA_b[,t+1] - A %*% m_tmp[,t] - b)
Vstar_tmp <- (diag(p_tmp) - Jt %*% A) %*% V_tmp[,,t]
Vstar_tmp <- (Vstar_tmp + t(Vstar_tmp))/2
BETA_b[,t] <- rmvnorm(1, mean = mstar_tmp,
sigma = Vstar_tmp)
}
return(BETA_b)
}
muX_new <- PG_FFBS(rbind(theta_a$mu, theta_a$X),
Y_tmp,cbind(rep(1,N_tmp), C_tmp),
theta_a$A,theta_a$b,
theta_a$Q,c(prior$mu0, prior$x0),
diag(c(prior$Sigmu0, diag(prior$Q0))),
R_tmp,delta_tmp)
eta_ori <- cbind(rep(1, N_tmp), delta_tmp, C_tmp) %*%
rbind(theta_a$mu, rep(1, T_all), theta_a$X)
eta_new <- cbind(rep(1, N_tmp), delta_tmp, C_tmp) %*%
rbind(muX_new[1,], rep(1, T_all), muX_new[-1,])
lam_ori <- exp(eta_ori)
lam_new <- exp(eta_new)
p_ori <- 1/(1 + exp(-eta_ori + log(R_tmp)))
p_new <- 1/(1 + exp(-eta_new + log(R_tmp)))
View(lam_ori)
View(lam_new)
sum(dpois(Y_tmp, lam_new, log = T))
sum(dpois(Y_tmp, lam_new, log = T), na.rm = T)
sum(dpois(Y_tmp, lam_new, log = T), na.rm = T) -
sum(dpois(Y_tmp, lam_ori, log = T), na.rm = T) +
sum(dnbinom(Y_tmp, R_tmp, prob = p_ori, log = T), na.rm = T) -
sum(dnbinom(Y_tmp, R_tmp, prob = p_new, log = T), na.rm = T)
sum(dpois(Y_tmp, lam_new, log = T), na.rm = T)
sum(dpois(Y_tmp, lam_ori, log = T), na.rm = T)
matplot(t(muX_new
))
C_tmp
cbind(rep(1, N_tmp), delta_tmp, C_tmp)
theta_a$X
rbind(theta_a$mu, rep(1, T_all), theta_a$X)
dim(rbind(theta_a$mu, rep(1, T_all), theta_a$X))
muX_new[1,]
dim(rbind(muX_new[1,], rep(1, T_all), muX_new[-1,]))
muX_new[-1,]
sum(dpois(Y_tmp, lam_new, log = T), na.rm = T)
sum(dpois(Y_tmp, lam_ori, log = T), na.rm = T)
sum(dnbinom(Y_tmp, R_tmp, prob = p_ori, log = T), na.rm = T)
sum(dnbinom(Y_tmp, R_tmp, prob = p_new, log = T), na.rm = T)
sum(dpois(Y_tmp, lam_new, log = T), na.rm = T) -
sum(dpois(Y_tmp, lam_ori, log = T), na.rm = T) +
sum(dnbinom(Y_tmp, R_tmp, prob = p_ori, log = T), na.rm = T) -
sum(dnbinom(Y_tmp, R_tmp, prob = p_new, log = T), na.rm = T)
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
log(runif(1))
setwd('D:\\github\\MFM_DPFA_Rversion\\function')
source('sample_prior.R')
source('update_clusParam_PG.R')
#############################################
#### read data & ground truth
setwd('D:\\github\\MFM_DPFA_Rversion\\data_gen')
## observation
Y <- as.matrix(read.csv('Y.csv', header = F))
lab <- c(as.matrix(read.csv('lab.csv', header = F)))
## ground truth
delta <- c(as.matrix(read.csv('delta.csv', header = F)))
mu <- as.matrix(read.csv('mu.csv', header = F))
X <- as.matrix(read.csv('X.csv', header = F))
logLam <- as.matrix(read.csv('logLam.csv', header = F))
for(i in 1:10){
Y[i,sample(1:1000, 500)] <- NA
}
###########################################
#### pre-MCMC: priors & settings
N <- dim(Y)[1]
T_all <- dim(Y)[2]
p_max <- N - 1
nClus <- length(unique(lab))
## priors
prior <- list()
prior$mu0 <- 0
prior$Sigmu0 <- 1
prior$BA0 <- c(0,1)
prior$Lamb0 <- diag(2)
prior$nu0 <- 1
prior$sig20 <- 0.01
## pre-allocation
ng <- 1000 # total iterations
delta_fit <- matrix(NA, nrow = N, ncol = ng)
C_fit <- array(0, dim = c(N,p_max, ng))
THETA <- list()
THETA[[1]] <- list()
## initialization
delta_fit[,1] <- rnorm(N)
for(kk in 1:nClus){
idx_tmp <- (lab == kk)
N_tmp <- sum(idx_tmp)
p_tmp <- 0 # 1
prior$x0 <- rep(0,p_tmp)
prior$Q0 <- diag(p_tmp)
if(p_tmp > 0){
C_fit[idx_tmp, 1:p_tmp, 1] <- matrix(rnorm(N_tmp*p_tmp), nrow = N_tmp)
}else{
C_fit[idx_tmp, 1, 1] <- 0
}
THETA[[1]][[kk]] <- list()
THETA[[1]][[kk]] <- sample_prior(prior, T_all, p_tmp)
THETA[[1]][[kk]]$p <- p_tmp
}
###########################################
#### MCMC
r_all <- 10
ACC_trace <- matrix(NA, nrow = nClus, ncol = ng)
ACC <- rep(NA, nClus)
g <- 2
cat(paste("iter = ", g))
THETA[[g]] <- THETA[[g-1]]
delta_fit[,g] <- delta_fit[,g-1]
C_fit[,,g] <- C_fit[,,g-1]
j <- 1
idx_tmp <- (lab == j)
p_tmp <- THETA[[g]][[j]]$p
prior$x0 <- rep(0,p_tmp)
prior$Q0 <- diag(p_tmp)
if(p_tmp > 0){
C_tmp <- C_fit[idx_tmp,1:p_tmp,g-1]
}else{
C_tmp <- numeric(0)
}
res <- update_clusParam_PG(
THETA[[g-1]][[j]],
delta_fit[idx_tmp,g-1],
C_tmp,
Y[idx_tmp,],
prior,
matrix(r_all, nrow = sum(idx_tmp), ncol = T_all))
res$acc
res$theta_b
for(j in 1:nClus){
idx_tmp <- (lab == j)
p_tmp <- THETA[[g]][[j]]$p
prior$x0 <- rep(0,p_tmp)
prior$Q0 <- diag(p_tmp)
if(p_tmp > 0){
C_tmp <- C_fit[idx_tmp,1:p_tmp,g-1]
}else{
C_tmp <- numeric(0)
}
res <- update_clusParam_PG(
THETA[[g-1]][[j]],
delta_fit[idx_tmp,g-1],
C_tmp,
Y[idx_tmp,],
prior,
matrix(r_all, nrow = sum(idx_tmp), ncol = T_all))
THETA[[g]][[j]] <- res$theta_b
ACC_trace[j,g] <- res$acc
ACC[j] <- sum(ACC_trace[j,2:g])/(g-1)
}
setwd('D:\\github\\MFM_DPFA_Rversion\\function')
source('sample_prior.R')
source('update_clusParam_PG.R')
#############################################
#### read data & ground truth
setwd('D:\\github\\MFM_DPFA_Rversion\\data_gen')
## observation
Y <- as.matrix(read.csv('Y.csv', header = F))
lab <- c(as.matrix(read.csv('lab.csv', header = F)))
## ground truth
delta <- c(as.matrix(read.csv('delta.csv', header = F)))
mu <- as.matrix(read.csv('mu.csv', header = F))
X <- as.matrix(read.csv('X.csv', header = F))
logLam <- as.matrix(read.csv('logLam.csv', header = F))
# for(i in 1:10){
#   Y[i,sample(1:1000, 500)] <- NA
# }
###########################################
#### pre-MCMC: priors & settings
N <- dim(Y)[1]
T_all <- dim(Y)[2]
p_max <- N - 1
nClus <- length(unique(lab))
## priors
prior <- list()
prior$mu0 <- 0
prior$Sigmu0 <- 1
prior$BA0 <- c(0,1)
prior$Lamb0 <- diag(2)
prior$nu0 <- 1
prior$sig20 <- 0.01
## pre-allocation
ng <- 1000 # total iterations
delta_fit <- matrix(NA, nrow = N, ncol = ng)
C_fit <- array(0, dim = c(N,p_max, ng))
THETA <- list()
THETA[[1]] <- list()
## initialization
delta_fit[,1] <- rnorm(N)
for(kk in 1:nClus){
idx_tmp <- (lab == kk)
N_tmp <- sum(idx_tmp)
p_tmp <- 1 # 1
prior$x0 <- rep(0,p_tmp)
prior$Q0 <- diag(p_tmp)
if(p_tmp > 0){
C_fit[idx_tmp, 1:p_tmp, 1] <- matrix(rnorm(N_tmp*p_tmp), nrow = N_tmp)
}else{
C_fit[idx_tmp, 1, 1] <- 0
}
THETA[[1]][[kk]] <- list()
THETA[[1]][[kk]] <- sample_prior(prior, T_all, p_tmp)
THETA[[1]][[kk]]$p <- p_tmp
}
r_all <- 10
ACC_trace <- matrix(NA, nrow = nClus, ncol = ng)
ACC <- rep(NA, nClus)
g <- 2
cat(paste("iter = ", g))
THETA[[g]] <- THETA[[g-1]]
delta_fit[,g] <- delta_fit[,g-1]
C_fit[,,g] <- C_fit[,,g-1]
# (1) update cluster parameters, by (PG + FFBS + MH)
for(j in 1:nClus){
idx_tmp <- (lab == j)
p_tmp <- THETA[[g]][[j]]$p
prior$x0 <- rep(0,p_tmp)
prior$Q0 <- diag(p_tmp)
if(p_tmp > 0){
C_tmp <- C_fit[idx_tmp,1:p_tmp,g-1]
}else{
C_tmp <- numeric(0)
}
res <- update_clusParam_PG(
THETA[[g-1]][[j]],
delta_fit[idx_tmp,g-1],
C_tmp,
Y[idx_tmp,],
prior,
matrix(r_all, nrow = sum(idx_tmp), ncol = T_all))
THETA[[g]][[j]] <- res$theta_b
ACC_trace[j,g] <- res$acc
ACC[j] <- sum(ACC_trace[j,2:g])/(g-1)
}
setwd('D:\\github\\MFM_DPFA_Rversion\\function')
source('sample_prior.R')
source('update_clusParam_PG.R')
#############################################
#### read data & ground truth
setwd('D:\\github\\MFM_DPFA_Rversion\\data_gen')
## observation
Y <- as.matrix(read.csv('Y.csv', header = F))
lab <- c(as.matrix(read.csv('lab.csv', header = F)))
## ground truth
delta <- c(as.matrix(read.csv('delta.csv', header = F)))
mu <- as.matrix(read.csv('mu.csv', header = F))
X <- as.matrix(read.csv('X.csv', header = F))
logLam <- as.matrix(read.csv('logLam.csv', header = F))
# for(i in 1:10){
#   Y[i,sample(1:1000, 500)] <- NA
# }
###########################################
#### pre-MCMC: priors & settings
N <- dim(Y)[1]
T_all <- dim(Y)[2]
p_max <- N - 1
nClus <- length(unique(lab))
## priors
prior <- list()
prior$mu0 <- 0
prior$Sigmu0 <- 1
prior$BA0 <- c(0,1)
prior$Lamb0 <- diag(2)
prior$nu0 <- 1
prior$sig20 <- 0.01
## pre-allocation
ng <- 1000 # total iterations
delta_fit <- matrix(NA, nrow = N, ncol = ng)
C_fit <- array(0, dim = c(N,p_max, ng))
THETA <- list()
THETA[[1]] <- list()
## initialization
delta_fit[,1] <- rnorm(N)
for(kk in 1:nClus){
idx_tmp <- (lab == kk)
N_tmp <- sum(idx_tmp)
p_tmp <- 1 # 1
prior$x0 <- rep(0,p_tmp)
prior$Q0 <- diag(p_tmp)
if(p_tmp > 0){
C_fit[idx_tmp, 1:p_tmp, 1] <- matrix(rnorm(N_tmp*p_tmp), nrow = N_tmp)
}else{
C_fit[idx_tmp, 1, 1] <- 0
}
THETA[[1]][[kk]] <- list()
THETA[[1]][[kk]] <- sample_prior(prior, T_all, p_tmp)
THETA[[1]][[kk]]$p <- p_tmp
}
r_all <- 10
ACC_trace <- matrix(NA, nrow = nClus, ncol = ng)
ACC <- rep(NA, nClus)
g <- 2
cat(paste("iter = ", g))
THETA[[g]] <- THETA[[g-1]]
delta_fit[,g] <- delta_fit[,g-1]
C_fit[,,g] <- C_fit[,,g-1]
# (1) update cluster parameters, by (PG + FFBS + MH)
for(j in 1:nClus){
idx_tmp <- (lab == j)
p_tmp <- THETA[[g]][[j]]$p
prior$x0 <- rep(0,p_tmp)
prior$Q0 <- diag(p_tmp)
if(p_tmp > 0){
C_tmp <- C_fit[idx_tmp,1:p_tmp,g-1]
}else{
C_tmp <- numeric(0)
}
res <- update_clusParam_PG(
THETA[[g-1]][[j]],
delta_fit[idx_tmp,g-1],
C_tmp,
Y[idx_tmp,],
prior,
matrix(r_all, nrow = sum(idx_tmp), ncol = T_all))
THETA[[g]][[j]] <- res$theta_b
ACC_trace[j,g] <- res$acc
ACC[j] <- sum(ACC_trace[j,2:g])/(g-1)
}
cat(paste("iter = ", g))
THETA[[g]] <- THETA[[g-1]]
delta_fit[,g] <- delta_fit[,g-1]
C_fit[,,g] <- C_fit[,,g-1]
# (1) update cluster parameters, by (PG + FFBS + MH)
for(j in 1:nClus){
idx_tmp <- (lab == j)
p_tmp <- THETA[[g]][[j]]$p
prior$x0 <- rep(0,p_tmp)
prior$Q0 <- diag(p_tmp)
if(p_tmp > 0){
C_tmp <- C_fit[idx_tmp,1:p_tmp,g-1]
}else{
C_tmp <- numeric(0)
}
res <- update_clusParam_PG(
THETA[[g-1]][[j]],
delta_fit[idx_tmp,g-1],
C_tmp,
Y[idx_tmp,],
prior,
matrix(r_all, nrow = sum(idx_tmp), ncol = T_all))
THETA[[g]][[j]] <- res$theta_b
ACC_trace[j,g] <- res$acc
ACC[j] <- sum(ACC_trace[j,2:g])/(g-1)
}
res
